#!/bin/bash
# snippet-picker - Quick snippet selection for Claude Code agents
# Usage: Called from tmux popup, sends selected snippet to active pane
# Supports folders via # ═══ FOLDER ═══ headers in snippets file
# Pane-aware: Shows relevant snippets based on current pane (PLAN/WORK/REVIEW)
# Direct mode: When context detected, shows snippets directly (skip folder selection)

SNIPPETS_FILE="${HOME}/.config/agent-snippets/snippets.txt"

# Detect current pane context for smart filtering
detect_pane_context() {
    # First try @role (set by agent-session)
    local role=$(tmux display-message -p '#{@role}' 2>/dev/null)
    if [ -n "$role" ]; then
        echo "$role"
        return
    fi

    # Fallback to pane title
    local title=$(tmux display-message -p '#{pane_title}' 2>/dev/null)
    case "$title" in
        PLAN*) echo "PLAN" ;;
        WORK*) echo "WORK" ;;
        REVIEW*) echo "REVIEW" ;;
        *) echo "" ;;
    esac
}

# Get folder filter pattern based on pane context
get_pane_folder_filter() {
    local context="$1"
    case "$context" in
        PLAN)   echo "^(PLAN|EVERY|HANDOFF)" ;;
        WORK)   echo "^(WORK|EVERY|QUICK)" ;;
        REVIEW) echo "^(REVIEW|EVERY)" ;;
        *)      echo "" ;;  # No filter - show all
    esac
}

CURRENT_PANE=$(detect_pane_context)
PANE_FILTER=$(get_pane_folder_filter "$CURRENT_PANE")

# Check if snippets file exists
if [[ ! -f "$SNIPPETS_FILE" ]]; then
    echo "No snippets file found at $SNIPPETS_FILE"
    echo "Press any key to exit..."
    read -n 1
    exit 1
fi

# Check if fzf is installed
if ! command -v fzf &> /dev/null; then
    echo "fzf is required but not installed."
    echo "Install with: brew install fzf"
    read -n 1
    exit 1
fi

# Parse snippets with folder information
# Output: FOLDER/Label\tContent
parse_snippets() {
    awk '
        BEGIN { folder="General"; label=""; content="" }

        # Folder headers - match any pattern like "# ═══ FOLDERNAME ═══"
        /^# ═══.*═══/ {
            folder = $0
            sub(/^# ═══ /, "", folder)
            sub(/ ═══.*$/, "", folder)
            next
        }

        # Skip comments
        /^#/ { next }

        # Skip empty lines
        /^[[:space:]]*$/ { next }

        # Separator - output accumulated snippet
        /^---/ {
            if (label != "" && content != "") {
                gsub(/\n/, "\\n", content)
                print folder "/" label "\t" content
            }
            label = ""
            content = ""
            next
        }

        # First non-empty line after separator is the label
        label == "" {
            label = $0
            next
        }

        # Subsequent lines are content
        {
            if (content == "") {
                content = $0
            } else {
                content = content "\n" $0
            }
        }

        END {
            # Output last snippet if any
            if (label != "" && content != "") {
                gsub(/\n/, "\\n", content)
                print folder "/" label "\t" content
            }
        }
    ' "$SNIPPETS_FILE"
}

# Format snippets for direct display: [FOLDER] Label\tFOLDER/Label\tContent
format_direct_snippets() {
    local filter_pattern="$1"
    echo "$PARSED_SNIPPETS" | grep -E "$filter_pattern" | while IFS=$'\t' read -r path content; do
        folder=$(echo "$path" | cut -d'/' -f1)
        label=$(echo "$path" | cut -d'/' -f2-)
        printf "[%s] %s\t%s\t%s\n" "$folder" "$label" "$path" "$content"
    done
}

# Main navigation loop
# Cache parsed snippets for performance
PARSED_SNIPPETS=$(parse_snippets)

# Get workflow suggestion if available
WORKFLOW_SUGGESTION=""
if command -v agent-flow-state &>/dev/null; then
    WORKFLOW_SUGGESTION=$(agent-flow-state suggest 2>/dev/null || true)
fi

# Track if we should use direct mode
USE_DIRECT_MODE=true

while true; do
    # Direct mode: show snippets directly when context is detected
    if [[ -n "$PANE_FILTER" && -n "$CURRENT_PANE" && "$USE_DIRECT_MODE" == "true" ]]; then
        direct_snippets=$(format_direct_snippets "$PANE_FILTER")

        if [[ -n "$direct_snippets" ]]; then
            # Build header
            header="[$CURRENT_PANE] Select snippet (<- back, ? help, ESC quit)"
            if [[ -n "$WORKFLOW_SUGGESTION" ]]; then
                header="$header | $WORKFLOW_SUGGESTION"
            fi

            # Show direct snippets with "Browse All Folders" at top
            selected=$(printf "%s\n%s" "Browse All Folders" "$direct_snippets" | \
                fzf --height=100% \
                    --layout=reverse \
                    --border=rounded \
                    --prompt="[$CURRENT_PANE] > " \
                    --header="$header" \
                    --delimiter=$'\t' \
                    --with-nth=1 \
                    --preview='echo {4} | sed "s/\\\\n/\n/g"' \
                    --preview-window=down:4:wrap \
                    --bind='left:abort' \
                    --bind='?:execute(~/.local/bin/agent-help)' \
                    --expect='left')

            # Check if left arrow was pressed or empty (ESC)
            first_line=$(echo "$selected" | head -1)
            if [[ -z "$selected" ]]; then
                exit 0  # ESC was pressed
            fi
            if [[ "$first_line" == "left" ]]; then
                exit 0  # Left arrow in direct mode = exit
            fi

            # Extract actual selection (skip the expect key line)
            selected=$(echo "$selected" | tail -n +2)
            [[ -z "$selected" ]] && exit 0

            # Check if "Browse All Folders" was selected
            if [[ "$selected" == "Browse All Folders" ]]; then
                USE_DIRECT_MODE=false
                continue  # Fall through to folder selection
            fi

            # Extract the content (4th field after tabs)
            text=$(echo "$selected" | cut -f4)

            # Replace \n with actual newlines
            text=$(echo "$text" | sed 's/\\n/\n/g')

            # Send the text without auto-submit for security
            tmux send-keys "$text"
            exit 0
        fi
    fi

    # Folder selection mode
    all_folders=$(echo "$PARSED_SNIPPETS" | cut -d'/' -f1 | sort -u)

    # Build folder list with pane-aware filtering
    folder_list=""

    # If we have a pane context, show suggested folders first
    if [[ -n "$PANE_FILTER" && -n "$CURRENT_PANE" ]]; then
        folder_list="[$CURRENT_PANE] Suggested"$'\n'

        # Add matching folders
        while IFS= read -r f; do
            if echo "$f" | grep -qE "$PANE_FILTER"; then
                folder_list+="  $f"$'\n'
            fi
        done <<< "$all_folders"

        folder_list+="All Snippets"$'\n'

        # Add non-matching folders under "Other"
        while IFS= read -r f; do
            if ! echo "$f" | grep -qE "$PANE_FILTER"; then
                folder_list+="  $f"$'\n'
            fi
        done <<< "$all_folders"
    else
        # No pane context - show all folders normally
        folder_list="All Snippets"$'\n'

        # Add EVERY folders first
        while IFS= read -r f; do
            [[ "$f" == EVERY* ]] && folder_list+="  $f"$'\n'
        done <<< "$all_folders"

        # Add other folders
        while IFS= read -r f; do
            [[ "$f" != EVERY* ]] && folder_list+="  $f"$'\n'
        done <<< "$all_folders"
    fi

    # Build header with workflow suggestion
    header="Select folder (<- cancel, ? help, ESC quit)"
    if [[ -n "$WORKFLOW_SUGGESTION" ]]; then
        header="$header | $WORKFLOW_SUGGESTION"
    fi

    selected_folder=$(echo -e "$folder_list" | sed '/^$/d' | fzf \
        --height=100% \
        --layout=reverse \
        --border=rounded \
        --prompt="> " \
        --header="$header" \
        --no-preview \
        --bind='left:abort' \
        --bind='?:execute(~/.local/bin/agent-help)' \
        --expect='left')

    # Check if left arrow was pressed or empty (ESC)
    first_line=$(echo "$selected_folder" | head -1)
    if [[ -z "$selected_folder" ]]; then
        exit 0  # ESC was pressed
    fi
    if [[ "$first_line" == "left" ]]; then
        exit 0  # Left arrow = exit
    fi

    # Extract actual selection (skip the expect key line)
    selected_folder=$(echo "$selected_folder" | tail -n +2)
    [[ -z "$selected_folder" ]] && exit 0

    # Extract folder name (remove leading spaces and special prefixes)
    selected_folder=$(echo "$selected_folder" | sed 's/^[[:space:]]*//')

    # Handle special selections
    if [[ "$selected_folder" == "All Snippets" ]]; then
        FOLDER_FILTER=""
    elif [[ "$selected_folder" == *"] Suggested" ]]; then
        # "[PLAN] Suggested" etc - show all matching folders for this pane
        # Set filter to match the pane's folders
        FOLDER_FILTER="$PANE_FILTER"
    else
        FOLDER_FILTER="$selected_folder"
    fi

    # Step 2: Show snippets (filtered by folder if selected)
    if [[ -n "$FOLDER_FILTER" ]]; then
        # Check if FOLDER_FILTER is a regex pattern (from pane context)
        if [[ "$FOLDER_FILTER" == "^("* ]]; then
            # It's a regex pattern - filter using grep -E
            snippets=$(echo "$PARSED_SNIPPETS" | grep -E "$FOLDER_FILTER")
        else
            # It's a literal folder name
            snippets=$(echo "$PARSED_SNIPPETS" | grep "^$FOLDER_FILTER/")
        fi
    else
        snippets="$PARSED_SNIPPETS"
    fi

    # Show snippets with back navigation
    selected=$(echo "$snippets" | \
        fzf --height=100% \
            --layout=reverse \
            --border=rounded \
            --prompt="> " \
            --header="Select snippet (<- back, ? help, ESC quit)" \
            --delimiter="\t" \
            --with-nth=1 \
            --preview='echo {2} | sed "s/\\\\n/\n/g"' \
            --preview-window=down:4:wrap \
            --bind='left:abort' \
            --bind='?:execute(~/.local/bin/agent-help)' \
            --expect='left')

    # Check if left arrow was pressed (go back to folders)
    first_line=$(echo "$selected" | head -1)
    if [[ "$first_line" == "left" ]] || [[ -z "$selected" ]]; then
        # Left arrow or empty selection - check if truly cancelled
        if [[ -z "$selected" ]]; then
            exit 0  # ESC was pressed
        fi
        continue  # Left arrow - go back to folder selection
    fi

    # Extract actual selection (skip the expect key line)
    selected=$(echo "$selected" | tail -n +2)

    [[ -z "$selected" ]] && continue

    # Extract the content (everything after the tab)
    text=$(echo "$selected" | cut -f2-)

    # Replace \n with actual newlines
    text=$(echo "$text" | sed 's/\\n/\n/g')

    # Send the text without auto-submit for security
    tmux send-keys "$text"
    exit 0
done
